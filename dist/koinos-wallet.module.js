function e(e,s,t,n){return{getAddress:()=>e,getPrivateKey:()=>{throw new Error("getPrivateKey is not available")},signHash:async a=>{const{result:i}=await s.sendRequest(t,{scope:"signer",command:"signHash",arguments:JSON.stringify({signerAddress:e,hash:a})},n);return i},signMessage:async a=>{const{result:i}=await s.sendRequest(t,{scope:"signer",command:"signMessage",arguments:JSON.stringify({signerAddress:e,message:a})},n);return i},prepareTransaction:async a=>{const{result:i}=await s.sendRequest(t,{scope:"signer",command:"prepareTransaction",arguments:JSON.stringify({signerAddress:e,transaction:a})},n);return i},signTransaction:async(a,i)=>{const{result:r}=await s.sendRequest(t,{scope:"signer",command:"signTransaction",arguments:JSON.stringify({signerAddress:e,transaction:a,options:{abis:i}})},n);return r},sendTransaction:async(a,i)=>{const{result:r}=await s.sendRequest(t,{scope:"signer",command:"signAndSendTransaction",arguments:JSON.stringify({signerAddress:e,transaction:a,options:i})},n);return r},prepareBlock:()=>{throw new Error("prepareBlock is not available")},signBlock:()=>{throw new Error("signBlock is not available")}}}const s="messenger::ping::request";class t{constructor(e,s,t=!0,n="*"){this.id=s,this.target=e,this.isTargetWindow=t,this.targetOrigin=n,this.onMessageListenerAdded=!1,this.addMessageListener()}onMessageListener=async e=>{if("*"!==this.targetOrigin&&!this.targetOrigin.startsWith(e.origin))return;const{data:t,ports:n}=e;t.type!==s&&t.to!==this.id||(t&&n&&n[0]?(t.type===s?n[0].postMessage({type:"messenger::ping::ack"}):this.onRequestFn&&await this.onRequestFn({sender:e.origin,data:JSON.parse(t.data),sendData:e=>{n[0].postMessage({data:e})},sendError:e=>{n[0].postMessage({error:e})}}),n[0].close()):t&&this.onMessageFn&&this.onMessageFn({sender:e.origin,data:JSON.parse(t.data)}))};addMessageListener=()=>{this.onMessageListenerAdded||(this.onMessageListenerAdded=!0,self.addEventListener("message",this.onMessageListener))};ping=async(e,t=20)=>{if(!this.onMessageListenerAdded)throw new Error("ping was cancelled");try{await this._sendRequest({type:s,from:this.id,to:e},500)}catch(s){if(--t<=0)throw new Error(`could not ping target "${e}"`);await this.ping(e,t)}};onMessage=e=>{this.onMessageFn=e};onRequest=e=>{this.onRequestFn=e};removeListener=()=>{this.onMessageListenerAdded&&(this.onMessageListenerAdded=!1,self.removeEventListener("message",this.onMessageListener))};sendMessage=(e,s)=>this._sendMessage({data:JSON.stringify(s),to:e,from:this.id});_sendMessage=e=>{this.isTargetWindow?this.target.postMessage(e,this.targetOrigin):this.target.postMessage(e)};sendRequest=(e,s,t=1e4)=>this._sendRequest({data:JSON.stringify(s),to:e,from:this.id},t);_sendRequest=(e,s=1e4)=>new Promise(((t,n)=>{let a;const{port1:i,port2:r}=new MessageChannel;i.onmessage=e=>{a&&self.clearTimeout(a),i.close();const s=e.data;s.error?n(s.error):t(s.data)},this.isTargetWindow?this.target.postMessage(e,this.targetOrigin,[r]):this.target.postMessage(e,[r]),s&&(a=self.setTimeout((()=>{n("request timed out")}),s))}))}let n=!1;const a="koinos-wallet-iframe",i="wallet-connector-child";new Promise(((e,s)=>{n?e():["loaded","interactive","complete"].indexOf(document.readyState)>-1?(n=!0,e()):window.addEventListener("load",(()=>{n=!0,e()}),!1)})).then((()=>{document.getElementsByClassName(a).length&&console.warn("Koinos-Wallet script was already loaded. This might cause unexpected behavior. If loading with a <script> tag, please make sure that you only load it once.")})).catch((()=>{}));class r{constructor(e){this.iframe=document.createElement("iframe"),this.iframe.id=a,this.iframe.hidden=!0,this.iframe.onload=()=>this.onIframeLoad(),this.iframe.src=e,document.body.appendChild(this.iframe),r.checkIfAlreadyInitialized()}close(){this.messenger.removeListener()}async onIframeLoad(){this.messenger=new t(this.iframe.contentWindow,"wallet-connector-parent"),await this.messenger.ping(i),console.log("connected to koinos-wallet-connector")}static checkIfAlreadyInitialized(){document.getElementsByClassName(a).length&&console.warn("An instance of Koinos-Wallet was already initialized. This is probably a mistake. Make sure that you use the same Koinos-Wallet instance throughout your app.")}async getAccounts(e=6e4){const{result:s}=await this.messenger.sendRequest(i,{scope:"accounts",command:"getAccounts"},e);return s}getSigner(s,t=6e4){return e(s,this.messenger,i,t)}}export{r as default};
//# sourceMappingURL=koinos-wallet.module.js.map
