{"mappings":"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","sources":["src/signer.ts","src/util/Messenger.ts","src/util/onWindowLoad.ts","src/index.ts"],"sourcesContent":["import { SignerInterface } from 'koilib'\nimport {\n  BlockJson,\n  SendTransactionOptions,\n  TransactionJson,\n  TransactionJsonWait,\n  TransactionReceipt,\n} from 'koilib/lib/interface'\nimport { IncomingMessage, OutgoingMessage } from './interfaces'\nimport { Messenger } from './util/Messenger'\n\nexport default function generateSigner(\n  signerAddress: string,\n  messenger: Messenger<IncomingMessage, OutgoingMessage>,\n  walletConnectorMessengerId: string,\n  timeout: number\n): SignerInterface {\n  return {\n    getAddress: () => signerAddress,\n\n    getPrivateKey: (): string => {\n      throw new Error('getPrivateKey is not available')\n    },\n\n    signHash: async (hash: Uint8Array): Promise<Uint8Array> => {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'signer',\n        command: 'signHash',\n        arguments: JSON.stringify({\n          signerAddress,\n          hash,\n        })\n      }, timeout)\n\n      return result as Uint8Array\n    },\n\n    signMessage: async (message: string | Uint8Array): Promise<Uint8Array> => {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'signer',\n        command: 'signMessage',\n        arguments: JSON.stringify({\n          signerAddress,\n          message,\n        })\n      }, timeout)\n\n      return result as Uint8Array\n    },\n\n    prepareTransaction: async (\n      transaction: TransactionJson\n    ): Promise<TransactionJson> => {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'signer',\n        command: 'prepareTransaction',\n        arguments: JSON.stringify({\n          signerAddress,\n          transaction,\n        })\n      }, timeout)\n\n      return result as TransactionJson\n    },\n\n    signTransaction: async (\n      transaction: TransactionJson,\n      abis?: SendTransactionOptions['abis']\n    ): Promise<TransactionJson> => {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'signer',\n        command: 'signTransaction',\n        arguments: JSON.stringify({\n          signerAddress,\n          transaction,\n          options: {\n            abis\n          }\n        })\n      }, timeout)\n\n      return result as TransactionJson\n    },\n\n    sendTransaction: async (\n      transaction: TransactionJson,\n      options?: SendTransactionOptions\n    ): Promise<{\n      receipt: TransactionReceipt;\n      transaction: TransactionJsonWait;\n    }> => {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'signer',\n        command: 'signAndSendTransaction',\n        arguments: JSON.stringify({\n          signerAddress,\n          transaction,\n          options\n        })\n      }, timeout)\n\n      return result as {\n        receipt: TransactionReceipt;\n        transaction: TransactionJsonWait;\n      }\n      // response.transaction.wait = async (\n      //   type: 'byTransactionId' | 'byBlock' = 'byBlock',\n      //   timeout = 60000\n      // ) => {\n      //   return messenger.sendDomMessage('background', 'provider:wait', {\n      //     txId: response.transaction.id,\n      //     type,\n      //     timeout,\n      //   })\n      // }\n    },\n\n    prepareBlock: (): Promise<BlockJson> => {\n      throw new Error('prepareBlock is not available')\n    },\n\n    signBlock: (): Promise<BlockJson> => {\n      throw new Error('signBlock is not available')\n    },\n  }\n}\n","\nexport interface IMessage {\n  from: string\n  to?: string\n  type?: string\n  data?: string\n  error?: string\n}\n\nexport type SendDataFn<OutgoingDataType> = (data: OutgoingDataType) => void\nexport type SendErrorFn = (error: string) => void\n\nexport type OnRequestFnArgs<IncomingDataType, OutgoingDataType> = {\n  sender: string,\n  data: IncomingDataType,\n  sendData: SendDataFn<OutgoingDataType>,\n  sendError: SendErrorFn\n}\n\nexport type OnMessageFnArgs<IncomingDataType> = {\n  sender: string,\n  data: IncomingDataType\n}\n\nexport type OnMessageFnType<IncomingDataType> = (args: OnMessageFnArgs<IncomingDataType>) => Promise<void> | void\nexport type OnRequestFnType<IncomingDataType, OutgoingDataType> = (args: OnRequestFnArgs<IncomingDataType, OutgoingDataType>) => Promise<void> | void\n\nconst PING_REQUEST_TYPE = 'messenger::ping::request'\nconst PING_REQUEST_ACK_TYPE = 'messenger::ping::ack'\n\nexport class Messenger<IncomingDataType, OutgoingDataType> {\n  private id: string\n  private target: Window | ServiceWorker\n  private isTargetWindow: boolean\n  private targetOrigin: string\n  private onMessageFn?: OnMessageFnType<IncomingDataType>\n  private onRequestFn?: OnRequestFnType<IncomingDataType, OutgoingDataType>\n  private onMessageListenerAdded: boolean\n\n  constructor(target: Window | ServiceWorker, id: string, isTargetWindow = true, targetOrigin = '*') {\n    this.id = id\n    this.target = target\n    this.isTargetWindow = isTargetWindow\n    this.targetOrigin = targetOrigin\n    this.onMessageListenerAdded = false\n    this.addMessageListener()\n  }\n\n  private onMessageListener = async (event: MessageEvent<IMessage>) => {\n    if (this.targetOrigin !== '*' && !this.targetOrigin.startsWith(event.origin)) return\n\n    const { data, ports } = event\n\n    if (data.type !== PING_REQUEST_TYPE && data.to !== this.id) return\n\n    if (data && ports && ports[0]) {\n      if (data.type === PING_REQUEST_TYPE) {\n        ports[0].postMessage({ type: PING_REQUEST_ACK_TYPE })\n      } else if (this.onRequestFn) {\n        await this.onRequestFn({\n          sender: event.origin,\n          data: JSON.parse(data.data!),\n          sendData: (data: OutgoingDataType) => {\n            ports[0].postMessage({ data })\n          },\n          sendError: (error: string) => {\n            ports[0].postMessage({ error })\n          }\n        })\n      }\n\n      ports[0].close()\n    } else if (data) {\n      if (this.onMessageFn) {\n        this.onMessageFn({\n          sender: event.origin,\n          data: JSON.parse(data.data!)\n        })\n      }\n    }\n  }\n\n  private addMessageListener = () => {\n    if (!this.onMessageListenerAdded) {\n      this.onMessageListenerAdded = true\n      self.addEventListener('message', this.onMessageListener)\n    }\n  }\n\n  ping = async (targetId: string, numberOfAttempt: number = 20) => {\n    if (!this.onMessageListenerAdded) {\n      throw new Error('ping was cancelled')\n    }\n\n    try {\n      await this._sendRequest({ type: PING_REQUEST_TYPE, from: this.id, to: targetId }, 500)\n    } catch (error) {\n      if (--numberOfAttempt <= 0) {\n        throw new Error(`could not ping target \"${targetId}\"`)\n      }\n\n      await this.ping(targetId, numberOfAttempt)\n    }\n  }\n\n  onMessage = (onMessageFn: OnMessageFnType<IncomingDataType>) => {\n    this.onMessageFn = onMessageFn\n  }\n\n  onRequest = (onRequestFn: OnRequestFnType<IncomingDataType, OutgoingDataType>) => {\n    this.onRequestFn = onRequestFn\n  }\n\n  removeListener = () => {\n    if (this.onMessageListenerAdded) {\n      this.onMessageListenerAdded = false\n      self.removeEventListener('message', this.onMessageListener)\n    }\n  }\n\n  sendMessage = (targetId: string, message: OutgoingDataType) => this._sendMessage({ data: JSON.stringify(message), to: targetId, from: this.id })\n\n  private _sendMessage = (message: IMessage) => {\n    if (this.isTargetWindow) {\n      (this.target as Window).postMessage(message, this.targetOrigin)\n    } else {\n      (this.target as ServiceWorker).postMessage(message)\n    }\n  }\n\n  sendRequest = (targetId: string, message: OutgoingDataType, timeout = 10000) => this._sendRequest({ data: JSON.stringify(message), to: targetId, from: this.id }, timeout)\n\n  private _sendRequest = (message: IMessage, timeout = 10000) => (\n    new Promise<IncomingDataType>((resolve, reject) => {\n      let requestTimeout: number\n\n      const {\n        port1,\n        port2,\n      } = new MessageChannel()\n\n      port1.onmessage = (evt) => {\n        if (requestTimeout) {\n          self.clearTimeout(requestTimeout)\n        }\n        port1.close()\n\n        const message: IMessage = evt.data\n\n        if (message.error) {\n          reject(message.error)\n        } else {\n          resolve(message.data as IncomingDataType)\n        }\n      }\n\n\n      if (this.isTargetWindow) {\n        (this.target as Window).postMessage(message, this.targetOrigin, [port2])\n      } else {\n        (this.target as ServiceWorker).postMessage(message, [port2])\n      }\n\n      if (timeout) {\n        requestTimeout = self.setTimeout(() => {\n          reject('request timed out')\n        }, timeout)\n      }\n    })\n  )\n}","let loaded = false\n\nexport function onWindowLoad() {\n  return new Promise<void>((resolve, reject) => {\n    if (loaded) {\n      resolve()\n    } else if (['loaded', 'interactive', 'complete'].indexOf(document.readyState) > -1) {\n      loaded = true\n      resolve()\n    } else {\n      window.addEventListener(\n        'load',\n        () => {\n          loaded = true\n          resolve()\n        },\n        false,\n      )\n    }\n  })\n}","import { IncomingMessage, OutgoingMessage, Account, SignSendTransactionArguments, SignSendTransactionResult } from './interfaces'\nimport generateSigner from './signer'\nimport { Messenger } from './util/Messenger'\nimport { onWindowLoad } from './util/onWindowLoad'\n\nconst KOINOS_WALLET_IFRAME_CLASS = 'koinos-wallet-iframe'\nconst WALLET_CONNECTOR_MESSENGER_ID = 'wallet-connector-child'\nconst KOINOS_WALLET_MESSENGER_ID = 'wallet-connector-parent'\n\nonWindowLoad()\n  .then(() => {\n    if (document.getElementsByClassName(KOINOS_WALLET_IFRAME_CLASS).length) {\n      console.warn('Koinos-Wallet script was already loaded. This might cause unexpected behavior. If loading with a <script> tag, please make sure that you only load it once.')\n    }\n  })\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  .catch(() => { }) // Prevents unhandledPromiseRejectionWarning, which happens when using React SSR;\n\nexport default class KoinosWallet {\n  private messenger: Messenger<IncomingMessage, OutgoingMessage>\n  private iframe: HTMLIFrameElement\n\n  constructor(walletUrl: string) {\n    this.iframe = document.createElement('iframe')\n    this.iframe.id = KOINOS_WALLET_IFRAME_CLASS\n    this.iframe.hidden = true\n    this.iframe.onload = () => this.onIframeLoad()\n    this.iframe.src = walletUrl\n    document.body.appendChild(this.iframe)\n\n    KoinosWallet.checkIfAlreadyInitialized()\n  }\n\n  close() {\n    this.messenger.removeListener()\n  }\n\n  async onIframeLoad() {\n    this.messenger = new Messenger<IncomingMessage, OutgoingMessage>(this.iframe.contentWindow as Window, KOINOS_WALLET_MESSENGER_ID)\n\n    await this.messenger.ping(WALLET_CONNECTOR_MESSENGER_ID)\n    console.log('connected to koinos-wallet-connector')\n  }\n\n  private static checkIfAlreadyInitialized() {\n    if (document.getElementsByClassName(KOINOS_WALLET_IFRAME_CLASS).length) {\n      console.warn(\n        'An instance of Koinos-Wallet was already initialized. This is probably a mistake. Make sure that you use the same Koinos-Wallet instance throughout your app.',\n      )\n    }\n  }\n\n  async getAccounts(timeout = 60000) {\n    const { result } = await this.messenger.sendRequest(WALLET_CONNECTOR_MESSENGER_ID, {\n      scope: 'accounts',\n      command: 'getAccounts'\n    }, timeout)\n\n    return result as Account[]\n  }\n\n  getSigner(signerAddress: string, timeout: number = 60000) {\n    return generateSigner(signerAddress, this.messenger, WALLET_CONNECTOR_MESSENGER_ID, timeout)\n  }\n}"],"names":["$865f34fca5748888$export$2e2bcd8739ae039","signerAddress","messenger","walletConnectorMessengerId","timeout","getAddress","getPrivateKey","Error","signHash","async","hash","result","sendRequest","scope","command","arguments","JSON","stringify","signMessage","message","prepareTransaction","transaction","signTransaction","abis","options","sendTransaction","prepareBlock","signBlock","$ee6e1563cce5e56e$var$PING_REQUEST_TYPE","$ee6e1563cce5e56e$export$1182391b36b9d1bf","constructor","target","id","isTargetWindow","targetOrigin","this","onMessageListenerAdded","addMessageListener","onMessageListener","event","startsWith","origin","data","ports","type","to","postMessage","onRequestFn","sender","parse","sendData","sendError","error","close","onMessageFn","self","addEventListener","ping","targetId","numberOfAttempt","_sendRequest","from","onMessage","onRequest","removeListener","removeEventListener","sendMessage","_sendMessage","Promise","resolve","reject","requestTimeout","port1","port2","MessageChannel","onmessage","evt","clearTimeout","setTimeout","$2f3652da40eb59b8$var$loaded","$23ccb22ac3ecb2a2$var$KOINOS_WALLET_IFRAME_CLASS","$23ccb22ac3ecb2a2$var$WALLET_CONNECTOR_MESSENGER_ID","indexOf","document","readyState","window","then","getElementsByClassName","length","console","warn","catch","$23ccb22ac3ecb2a2$export$2e2bcd8739ae039","walletUrl","iframe","createElement","hidden","onload","onIframeLoad","src","body","appendChild","checkIfAlreadyInitialized","contentWindow","log","static","getSigner"],"version":3,"file":"koinos-wallet.module.js.map"}