{"mappings":"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","sources":["src/provider.ts","src/signer.ts","src/util/Messenger.ts","src/util/onWindowLoad.ts","src/index.ts"],"sourcesContent":["import {\n  BlockJson,\n  CallContractOperationJson,\n  TransactionJson\n} from 'koilib/lib/interface'\nimport { IncomingMessage, OutgoingMessage, TransactionResult } from './interfaces'\nimport { Messenger } from './util/Messenger'\n\nexport default function generateProvider(\n  messenger: Messenger<IncomingMessage, OutgoingMessage>,\n  walletConnectorMessengerId: string,\n  timeout: number\n) {\n\n  return {\n    async call<T = unknown>(method: string, params: unknown): Promise<T> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'call',\n        arguments: JSON.stringify({\n          method,\n          params\n        })\n      }, timeout)\n\n\n      return result as T\n    },\n\n    async getNonce(account: string): Promise<number> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'getNonce',\n        arguments: JSON.stringify({\n          account\n        })\n      }, timeout)\n\n\n      return result as number\n    },\n\n    async getAccountRc(account: string): Promise<string> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'getAccountRc',\n        arguments: JSON.stringify({\n          account\n        })\n      }, timeout)\n\n\n      return result as string\n    },\n\n    async getTransactionsById(transactionIds: string[]): Promise<{\n      transactions: {\n        transaction: TransactionJson[];\n        containing_blocks: string[];\n      }[];\n    }> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'getTransactionsById',\n        arguments: JSON.stringify({\n          transactionIds\n        })\n      }, timeout)\n\n\n      return result as {\n        transactions: {\n          transaction: TransactionJson[];\n          containing_blocks: string[];\n        }[];\n      }\n    },\n\n    async getBlocksById(blockIds: string[]): Promise<{\n      block_items: {\n        block_id: string;\n        block_height: string;\n        block: BlockJson;\n      }[];\n    }> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'getBlocksById',\n        arguments: JSON.stringify({\n          blockIds\n        })\n      }, timeout)\n\n\n      return result as {\n        block_items: {\n          block_id: string;\n          block_height: string;\n          block: BlockJson;\n        }[];\n      }\n    },\n\n    async getHeadInfo(): Promise<{\n      head_topology: {\n        id: string;\n        height: string;\n        previous: string;\n      };\n      last_irreversible_block: string;\n    }> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'getHeadInfo',\n        arguments: JSON.stringify({\n\n        })\n      }, timeout)\n\n      return result as {\n        head_topology: {\n          id: string;\n          height: string;\n          previous: string;\n        };\n        last_irreversible_block: string;\n      }\n    },\n\n    async getChainId(): Promise<string> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'getChainId',\n        arguments: JSON.stringify({\n\n        })\n      }, timeout)\n\n      return result as string\n    },\n\n    async getBlocks(\n      height: number,\n      numBlocks = 1,\n      idRef?: string\n    ): Promise<\n      {\n        block_id: string;\n        block_height: string;\n        block: BlockJson;\n        block_receipt: {\n          [x: string]: unknown;\n        };\n      }[]\n    > {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'getBlocks',\n        arguments: JSON.stringify({\n          height,\n          numBlocks,\n          idRef\n        })\n      }, timeout)\n\n      return result as {\n        block_id: string;\n        block_height: string;\n        block: BlockJson;\n        block_receipt: {\n          [x: string]: unknown;\n        };\n      }[]\n    },\n\n    async getBlock(height: number): Promise<{\n      block_id: string;\n      block_height: string;\n      block: BlockJson;\n      block_receipt: {\n        [x: string]: unknown;\n      };\n    }> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'getBlock',\n        arguments: JSON.stringify({\n          height\n        })\n      }, timeout)\n\n      return result as {\n        block_id: string;\n        block_height: string;\n        block: BlockJson;\n        block_receipt: {\n          [x: string]: unknown;\n        };\n      }\n    },\n\n    async wait(\n      transactionId: string,\n      type: 'byTransactionId' | 'byBlock' = 'byBlock',\n      waitTimeout = 30000\n    ): Promise<{ blockId: string; blockNumber?: number }> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'wait',\n        arguments: JSON.stringify({\n          transactionId,\n          type,\n          timeout: waitTimeout\n        })\n      }, timeout)\n\n\n      return result as { blockId: string; blockNumber?: number }\n    },\n\n    async sendTransaction(\n      transaction: TransactionJson,\n      broadcast = true\n    ): Promise<TransactionResult> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'sendTransaction',\n        arguments: JSON.stringify({\n          transaction,\n          broadcast\n        })\n      }, timeout);\n\n      (result as TransactionResult).transaction.wait = async (\n        type: 'byTransactionId' | 'byBlock' = 'byBlock',\n        waitTimeout = 60000\n      ) => {\n        const { result: waitResult } = await messenger.sendRequest(walletConnectorMessengerId, {\n          scope: 'provider',\n          command: 'wait',\n          arguments: JSON.stringify({\n            transactionId: transaction.id,\n            type,\n            timeout: waitTimeout\n          })\n        }, timeout)\n\n\n        return waitResult as { blockId: string; blockNumber?: number }\n      }\n\n      return result as TransactionResult\n    },\n\n    async readContract(operation: CallContractOperationJson): Promise<{\n      result: string;\n      logs: string;\n    }> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'readContract',\n        arguments: JSON.stringify({\n          operation\n        })\n      }, timeout)\n\n      return result as {\n        result: string;\n        logs: string;\n      }\n    },\n\n    async submitBlock(block: BlockJson): Promise<Record<string, never>> {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'provider',\n        command: 'submitBlock',\n        arguments: JSON.stringify({\n          block\n        })\n      }, timeout)\n\n      return result as Record<string, never>\n    },\n  }\n}","import { SignerInterface } from 'koilib'\nimport {\n  BlockJson,\n  SendTransactionOptions,\n  TransactionJson,\n} from 'koilib/lib/interface'\nimport { IncomingMessage, OutgoingMessage, TransactionResult } from './interfaces'\nimport { Messenger } from './util/Messenger'\n\nexport default function generateSigner(\n  signerAddress: string,\n  messenger: Messenger<IncomingMessage, OutgoingMessage>,\n  walletConnectorMessengerId: string,\n  timeout: number\n): SignerInterface {\n  return {\n    getAddress: () => signerAddress,\n\n    getPrivateKey: (): string => {\n      throw new Error('not implemented')\n    },\n\n    signHash: async (hash: Uint8Array): Promise<Uint8Array> => {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'signer',\n        command: 'signHash',\n        arguments: JSON.stringify({\n          signerAddress,\n          hash,\n        })\n      }, timeout)\n\n      return result as Uint8Array\n    },\n\n    signMessage: async (message: string | Uint8Array): Promise<Uint8Array> => {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'signer',\n        command: 'signMessage',\n        arguments: JSON.stringify({\n          signerAddress,\n          message,\n        })\n      }, timeout)\n\n      return result as Uint8Array\n    },\n\n    prepareTransaction: async (\n      transaction: TransactionJson\n    ): Promise<TransactionJson> => {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'signer',\n        command: 'prepareTransaction',\n        arguments: JSON.stringify({\n          signerAddress,\n          transaction,\n        })\n      }, timeout)\n\n      return result as TransactionJson\n    },\n\n    signTransaction: async (\n      transaction: TransactionJson,\n      abis?: SendTransactionOptions['abis']\n    ): Promise<TransactionJson> => {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'signer',\n        command: 'signTransaction',\n        arguments: JSON.stringify({\n          signerAddress,\n          transaction,\n          options: {\n            abis\n          }\n        })\n      }, timeout)\n\n      return result as TransactionJson\n    },\n\n    sendTransaction: async (\n      transaction: TransactionJson,\n      options?: SendTransactionOptions\n    ): Promise<TransactionResult> => {\n      const { result } = await messenger.sendRequest(walletConnectorMessengerId, {\n        scope: 'signer',\n        command: 'signAndSendTransaction',\n        arguments: JSON.stringify({\n          signerAddress,\n          transaction,\n          options\n        })\n      }, timeout);\n\n      (result as TransactionResult).transaction.wait = async (\n        type: 'byTransactionId' | 'byBlock' = 'byBlock',\n        waitTimeout = 60000\n      ) => {\n        const { result: waitResult } = await messenger.sendRequest(walletConnectorMessengerId, {\n          scope: 'provider',\n          command: 'wait',\n          arguments: JSON.stringify({\n            transactionId: (result as TransactionResult).transaction.id,\n            type,\n            timeout: waitTimeout\n          })\n        }, timeout)\n\n\n        return waitResult as { blockId: string; blockNumber?: number }\n      }\n\n      return result as TransactionResult\n    },\n\n    prepareBlock: (): Promise<BlockJson> => {\n      throw new Error('not implemented')\n    },\n\n    signBlock: (): Promise<BlockJson> => {\n      throw new Error('not implemented')\n    },\n  }\n}\n","\nexport interface IMessage {\n  from: string\n  to?: string\n  type?: string\n  data?: string\n  error?: string\n}\n\nexport type SendDataFn<OutgoingDataType> = (data: OutgoingDataType) => void\nexport type SendErrorFn = (error: string) => void\n\nexport type OnRequestFnArgs<IncomingDataType, OutgoingDataType> = {\n  sender: string,\n  data: IncomingDataType,\n  sendData: SendDataFn<OutgoingDataType>,\n  sendError: SendErrorFn\n}\n\nexport type OnMessageFnArgs<IncomingDataType> = {\n  sender: string,\n  data: IncomingDataType\n}\n\nexport type OnMessageFnType<IncomingDataType> = (args: OnMessageFnArgs<IncomingDataType>) => Promise<void> | void\nexport type OnRequestFnType<IncomingDataType, OutgoingDataType> = (args: OnRequestFnArgs<IncomingDataType, OutgoingDataType>) => Promise<void> | void\n\nconst PING_REQUEST_TYPE = 'messenger::ping::request'\nconst PING_REQUEST_ACK_TYPE = 'messenger::ping::ack'\n\nexport class Messenger<IncomingDataType, OutgoingDataType> {\n  private id: string\n  private target: Window | ServiceWorker\n  private isTargetWindow: boolean\n  private targetOrigin: string\n  private onMessageFn?: OnMessageFnType<IncomingDataType>\n  private onRequestFn?: OnRequestFnType<IncomingDataType, OutgoingDataType>\n  private onMessageListenerAdded: boolean\n\n  constructor(target: Window | ServiceWorker, id: string, isTargetWindow = true, targetOrigin = '*') {\n    this.id = id\n    this.target = target\n    this.isTargetWindow = isTargetWindow\n    this.targetOrigin = targetOrigin\n    this.onMessageListenerAdded = false\n    this.addMessageListener()\n  }\n\n  private onMessageListener = async (event: MessageEvent<IMessage>) => {\n    if (this.targetOrigin !== '*' && !this.targetOrigin.startsWith(event.origin)) return\n\n    const { data, ports } = event\n\n    if (data.type !== PING_REQUEST_TYPE && data.to !== this.id) return\n\n    if (data && ports && ports[0]) {\n      if (data.type === PING_REQUEST_TYPE) {\n        ports[0].postMessage({ type: PING_REQUEST_ACK_TYPE })\n      } else if (this.onRequestFn) {\n        await this.onRequestFn({\n          sender: event.origin,\n          data: JSON.parse(data.data!),\n          sendData: (data: OutgoingDataType) => {\n            ports[0].postMessage({ data })\n          },\n          sendError: (error: string) => {\n            ports[0].postMessage({ error })\n          }\n        })\n      }\n\n      ports[0].close()\n    } else if (data) {\n      if (this.onMessageFn) {\n        this.onMessageFn({\n          sender: event.origin,\n          data: JSON.parse(data.data!)\n        })\n      }\n    }\n  }\n\n  private addMessageListener = () => {\n    if (!this.onMessageListenerAdded) {\n      this.onMessageListenerAdded = true\n      self.addEventListener('message', this.onMessageListener)\n    }\n  }\n\n  ping = async (targetId: string, numberOfAttempt: number = 20) => {\n    if (!this.onMessageListenerAdded) {\n      throw new Error('ping was cancelled')\n    }\n\n    try {\n      await this._sendRequest({ type: PING_REQUEST_TYPE, from: this.id, to: targetId }, 500)\n    } catch (error) {\n      if (--numberOfAttempt <= 0) {\n        throw new Error(`could not ping target \"${targetId}\"`)\n      }\n\n      await this.ping(targetId, numberOfAttempt)\n    }\n  }\n\n  onMessage = (onMessageFn: OnMessageFnType<IncomingDataType>) => {\n    this.onMessageFn = onMessageFn\n  }\n\n  onRequest = (onRequestFn: OnRequestFnType<IncomingDataType, OutgoingDataType>) => {\n    this.onRequestFn = onRequestFn\n  }\n\n  removeListener = () => {\n    if (this.onMessageListenerAdded) {\n      this.onMessageListenerAdded = false\n      self.removeEventListener('message', this.onMessageListener)\n    }\n  }\n\n  sendMessage = (targetId: string, message: OutgoingDataType) => this._sendMessage({ data: JSON.stringify(message), to: targetId, from: this.id })\n\n  private _sendMessage = (message: IMessage) => {\n    if (this.isTargetWindow) {\n      (this.target as Window).postMessage(message, this.targetOrigin)\n    } else {\n      (this.target as ServiceWorker).postMessage(message)\n    }\n  }\n\n  sendRequest = (targetId: string, message: OutgoingDataType, timeout = 10000) => this._sendRequest({ data: JSON.stringify(message), to: targetId, from: this.id }, timeout)\n\n  private _sendRequest = (message: IMessage, timeout = 10000) => (\n    new Promise<IncomingDataType>((resolve, reject) => {\n      let requestTimeout: number\n\n      const {\n        port1,\n        port2,\n      } = new MessageChannel()\n\n      port1.onmessage = (evt) => {\n        if (requestTimeout) {\n          self.clearTimeout(requestTimeout)\n        }\n        port1.close()\n\n        const message: IMessage = evt.data\n\n        if (message.error) {\n          reject(message.error)\n        } else {\n          resolve(message.data as IncomingDataType)\n        }\n      }\n\n\n      if (this.isTargetWindow) {\n        (this.target as Window).postMessage(message, this.targetOrigin, [port2])\n      } else {\n        (this.target as ServiceWorker).postMessage(message, [port2])\n      }\n\n      if (timeout) {\n        requestTimeout = self.setTimeout(() => {\n          reject('request timed out')\n        }, timeout)\n      }\n    })\n  )\n}","let loaded = false\n\nexport function onWindowLoad() {\n  return new Promise<void>((resolve, reject) => {\n    if (loaded) {\n      resolve()\n    } else if (['loaded', 'interactive', 'complete'].indexOf(document.readyState) > -1) {\n      loaded = true\n      resolve()\n    } else {\n      window.addEventListener(\n        'load',\n        () => {\n          loaded = true\n          resolve()\n        },\n        false,\n      )\n    }\n  })\n}","import { IncomingMessage, OutgoingMessage, Account } from './interfaces'\nimport generateProvider from './provider'\nimport generateSigner from './signer'\nimport { Messenger } from './util/Messenger'\nimport { onWindowLoad } from './util/onWindowLoad'\n\nconst KOINOS_WALLET_IFRAME_CLASS = 'koinos-wallet-iframe'\nconst WALLET_CONNECTOR_MESSENGER_ID = 'wallet-connector-child'\nconst KOINOS_WALLET_MESSENGER_ID = 'wallet-connector-parent'\n\nonWindowLoad()\n  .then(() => {\n    if (document.getElementsByClassName(KOINOS_WALLET_IFRAME_CLASS).length) {\n      console.warn('Koinos-Wallet script was already loaded. This might cause unexpected behavior. If loading with a <script> tag, please make sure that you only load it once.')\n    }\n  })\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  .catch(() => { }) // Prevents unhandledPromiseRejectionWarning, which happens when using React SSR;\n\nexport default class KoinosWallet {\n  private messenger: Messenger<IncomingMessage, OutgoingMessage>\n  private iframe: HTMLIFrameElement\n\n  constructor(walletUrl: string) {\n    this.iframe = document.createElement('iframe')\n    this.iframe.id = KOINOS_WALLET_IFRAME_CLASS\n    this.iframe.hidden = true\n    this.iframe.onload = () => this.onIframeLoad()\n    this.iframe.src = walletUrl\n    document.body.appendChild(this.iframe)\n\n    KoinosWallet.checkIfAlreadyInitialized()\n  }\n\n  close() {\n    if (this.messenger) {\n      this.messenger.removeListener()\n    }\n  }\n\n  async onIframeLoad() {\n    this.messenger = new Messenger<IncomingMessage, OutgoingMessage>(this.iframe.contentWindow as Window, KOINOS_WALLET_MESSENGER_ID)\n\n    await this.messenger.ping(WALLET_CONNECTOR_MESSENGER_ID)\n    console.log('connected to koinos-wallet-connector')\n  }\n\n  private static checkIfAlreadyInitialized() {\n    if (document.getElementsByClassName(KOINOS_WALLET_IFRAME_CLASS).length) {\n      console.warn(\n        'An instance of Koinos-Wallet was already initialized. This is probably a mistake. Make sure that you use the same Koinos-Wallet instance throughout your app.',\n      )\n    }\n  }\n\n  async getAccounts(timeout = 60000) {\n    const { result } = await this.messenger.sendRequest(WALLET_CONNECTOR_MESSENGER_ID, {\n      scope: 'accounts',\n      command: 'getAccounts'\n    }, timeout)\n\n    return result as Account[]\n  }\n\n  getSigner(signerAddress: string, timeout: number = 60000) {\n    return generateSigner(signerAddress, this.messenger, WALLET_CONNECTOR_MESSENGER_ID, timeout)\n  }\n\n  getProvider(timeout: number = 60000) {\n    return generateProvider(this.messenger, WALLET_CONNECTOR_MESSENGER_ID, timeout)\n  }\n}"],"names":["$c69a694e4c0b960f$export$2e2bcd8739ae039","messenger","walletConnectorMessengerId","timeout","async","method","params","result","sendRequest","scope","command","arguments","JSON","stringify","account","transactionIds","blockIds","height","numBlocks","idRef","transactionId","type","waitTimeout","transaction","broadcast","wait","waitResult","id","operation","block","$74fad728e4631da2$export$2e2bcd8739ae039","signerAddress","getAddress","getPrivateKey","Error","signHash","hash","signMessage","message","prepareTransaction","signTransaction","abis","options","sendTransaction","prepareBlock","signBlock","$37dc762e7429e685$var$PING_REQUEST_TYPE","$37dc762e7429e685$export$1182391b36b9d1bf","constructor","target","isTargetWindow","targetOrigin","this","onMessageListenerAdded","addMessageListener","onMessageListener","event","startsWith","origin","data","ports","to","postMessage","onRequestFn","sender","parse","sendData","sendError","error","close","onMessageFn","self","addEventListener","ping","targetId","numberOfAttempt","_sendRequest","from","onMessage","onRequest","removeListener","removeEventListener","sendMessage","_sendMessage","Promise","resolve","reject","requestTimeout","port1","port2","MessageChannel","onmessage","evt","clearTimeout","setTimeout","$0b19e43e35dee0e8$var$loaded","$eb7869949b641a40$var$KOINOS_WALLET_IFRAME_CLASS","$eb7869949b641a40$var$WALLET_CONNECTOR_MESSENGER_ID","indexOf","document","readyState","window","then","getElementsByClassName","length","console","warn","catch","$eb7869949b641a40$export$2e2bcd8739ae039","walletUrl","iframe","createElement","hidden","onload","onIframeLoad","src","body","appendChild","checkIfAlreadyInitialized","contentWindow","log","static","getSigner","getProvider"],"version":3,"file":"koinos-wallet.js.map"}