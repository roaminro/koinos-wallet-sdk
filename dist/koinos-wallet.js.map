{"mappings":"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","sources":["src/util/Messenger.ts","src/util/onWindowLoad.ts","src/index.ts"],"sourcesContent":["\nexport interface IMessage {\n  from: string\n  to?: string\n  type?: string\n  data?: string\n  error?: string\n}\n\nexport type SendDataFn<OutgoingDataType> = (data: OutgoingDataType) => void\nexport type SendErrorFn = (error: string) => void\n\nexport type OnRequestFnArgs<IncomingDataType, OutgoingDataType> = {\n  sender: string,\n  data: IncomingDataType,\n  sendData: SendDataFn<OutgoingDataType>,\n  sendError: SendErrorFn\n}\n\nexport type OnMessageFnArgs<IncomingDataType> = {\n  sender: string,\n  data: IncomingDataType\n}\n\nexport type OnMessageFnType<IncomingDataType> = (args: OnMessageFnArgs<IncomingDataType>) => Promise<void> | void\nexport type OnRequestFnType<IncomingDataType, OutgoingDataType> = (args: OnRequestFnArgs<IncomingDataType, OutgoingDataType>) => Promise<void> | void\n\nconst PING_REQUEST_TYPE = 'messenger::ping::request'\nconst PING_REQUEST_ACK_TYPE = 'messenger::ping::ack'\n\nexport class Messenger<IncomingDataType, OutgoingDataType> {\n  private id: string\n  private target: Window | ServiceWorker\n  private isTargetWindow: boolean\n  private targetOrigin: string\n  private onMessageFn?: OnMessageFnType<IncomingDataType>\n  private onRequestFn?: OnRequestFnType<IncomingDataType, OutgoingDataType>\n  private onMessageListenerAdded: boolean\n\n  constructor(target: Window | ServiceWorker, id: string, isTargetWindow = true, targetOrigin = '*') {\n    this.id = id\n    this.target = target\n    this.isTargetWindow = isTargetWindow\n    this.targetOrigin = targetOrigin\n    this.onMessageListenerAdded = false\n    this.addMessageListener()\n  }\n\n  private onMessageListener = async (event: MessageEvent<IMessage>) => {\n    if (this.targetOrigin !== '*' && !this.targetOrigin.startsWith(event.origin)) return\n\n    const { data, ports } = event\n\n    if (data.type !== PING_REQUEST_TYPE && data.to !== this.id) return\n\n    if (data && ports && ports[0]) {\n      if (data.type === PING_REQUEST_TYPE) {\n        ports[0].postMessage({ type: PING_REQUEST_ACK_TYPE })\n      } else if (this.onRequestFn) {\n        await this.onRequestFn({\n          sender: event.origin,\n          data: JSON.parse(data.data!),\n          sendData: (data: OutgoingDataType) => {\n            ports[0].postMessage({ data })\n          },\n          sendError: (error: string) => {\n            ports[0].postMessage({ error })\n          }\n        })\n      }\n\n      ports[0].close()\n    } else if (data) {\n      if (this.onMessageFn) {\n        this.onMessageFn({\n          sender: event.origin,\n          data: JSON.parse(data.data!)\n        })\n      }\n    }\n  }\n\n  private addMessageListener = () => {\n    if (!this.onMessageListenerAdded) {\n      this.onMessageListenerAdded = true\n      self.addEventListener('message', this.onMessageListener)\n    }\n  }\n\n  ping = async (targetId: string, numberOfAttempt: number = 20) => {\n    if (!this.onMessageListenerAdded) {\n      throw new Error('ping was cancelled')\n    }\n\n    try {\n      await this._sendRequest({ type: PING_REQUEST_TYPE, from: this.id, to: targetId }, 500)\n    } catch (error) {\n      if (--numberOfAttempt <= 0) {\n        throw new Error(`could not ping target \"${targetId}\"`)\n      }\n\n      await this.ping(targetId, numberOfAttempt)\n    }\n  }\n\n  onMessage = (onMessageFn: OnMessageFnType<IncomingDataType>) => {\n    this.onMessageFn = onMessageFn\n  }\n\n  onRequest = (onRequestFn: OnRequestFnType<IncomingDataType, OutgoingDataType>) => {\n    this.onRequestFn = onRequestFn\n  }\n\n  removeListener = () => {\n    if (this.onMessageListenerAdded) {\n      this.onMessageListenerAdded = false\n      self.removeEventListener('message', this.onMessageListener)\n    }\n  }\n\n  sendMessage = (targetId: string, message: OutgoingDataType) => this._sendMessage({ data: JSON.stringify(message), to: targetId, from: this.id })\n\n  private _sendMessage = (message: IMessage) => {\n    if (this.isTargetWindow) {\n      (this.target as Window).postMessage(message, this.targetOrigin)\n    } else {\n      (this.target as ServiceWorker).postMessage(message)\n    }\n  }\n\n  sendRequest = (targetId: string, message: OutgoingDataType, timeout = 10000) => this._sendRequest({ data: JSON.stringify(message), to: targetId, from: this.id }, timeout)\n\n  private _sendRequest = (message: IMessage, timeout = 10000) => (\n    new Promise<IncomingDataType>((resolve, reject) => {\n      let requestTimeout: number\n\n      const {\n        port1,\n        port2,\n      } = new MessageChannel()\n\n      port1.onmessage = (evt) => {\n        if (requestTimeout) {\n          self.clearTimeout(requestTimeout)\n        }\n        port1.close()\n\n        const message: IMessage = evt.data\n\n        if (message.error) {\n          reject(message.error)\n        } else {\n          resolve(message.data as IncomingDataType)\n        }\n      }\n\n\n      if (this.isTargetWindow) {\n        (this.target as Window).postMessage(message, this.targetOrigin, [port2])\n      } else {\n        (this.target as ServiceWorker).postMessage(message, [port2])\n      }\n\n      if (timeout) {\n        requestTimeout = self.setTimeout(() => {\n          reject('request timed out')\n        }, timeout)\n      }\n    })\n  )\n}","let loaded = false\n\nexport function onWindowLoad() {\n  return new Promise<void>((resolve, reject) => {\n    if (loaded) {\n      resolve()\n    } else if (['loaded', 'interactive', 'complete'].indexOf(document.readyState) > -1) {\n      loaded = true\n      resolve()\n    } else {\n      window.addEventListener(\n        'load',\n        () => {\n          loaded = true\n          resolve()\n        },\n        false,\n      )\n    }\n  })\n}","import { IncomingMessage, OutgoingMessage, Account, SignSendTransactionArguments, SignSendTransactionResult } from './interfaces'\nimport { Messenger } from './util/Messenger'\nimport { onWindowLoad } from './util/onWindowLoad'\n\nconst KOINOS_WALLET_IFRAME_CLASS = 'koinos-wallet-iframe'\nconst WALLET_CONNECTOR_MESSENGER_ID = 'wallet-connector-child'\nconst KOINOS_WALLET_MESSENGER_ID = 'wallet-connector-parent'\n\nonWindowLoad()\n  .then(() => {\n    if (document.getElementsByClassName(KOINOS_WALLET_IFRAME_CLASS).length) {\n      console.warn('Koinos-Wallet script was already loaded. This might cause unexpected behavior. If loading with a <script> tag, please make sure that you only load it once.')\n    }\n  })\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  .catch(() => { }) // Prevents unhandledPromiseRejectionWarning, which happens when using React SSR;\n\nexport default class KoinosWallet {\n  private messenger: Messenger<IncomingMessage, OutgoingMessage>\n  private iframe: HTMLIFrameElement\n\n  constructor(walletUrl: string) {\n    this.iframe = document.createElement('iframe')\n    this.iframe.id = KOINOS_WALLET_IFRAME_CLASS\n    this.iframe.hidden = true\n    this.iframe.onload = () => this.onIframeLoad()\n    this.iframe.src = walletUrl\n    document.body.appendChild(this.iframe)\n\n    KoinosWallet.checkIfAlreadyInitialized()\n  }\n\n  close() {\n    this.messenger.removeListener()\n  }\n\n  async onIframeLoad() {\n    this.messenger = new Messenger<IncomingMessage, OutgoingMessage>(this.iframe.contentWindow as Window, KOINOS_WALLET_MESSENGER_ID)\n\n    await this.messenger.ping(WALLET_CONNECTOR_MESSENGER_ID)\n    console.log('connected to koinos-wallet-connector')\n  }\n\n  private static checkIfAlreadyInitialized() {\n    if (document.getElementsByClassName(KOINOS_WALLET_IFRAME_CLASS).length) {\n      console.warn(\n        'An instance of Koinos-Wallet was already initialized. This is probably a mistake. Make sure that you use the same Koinos-Wallet instance throughout your app.',\n      )\n    }\n  }\n\n  async getAccounts(timeout = 60000) {\n    const { result } = await this.messenger.sendRequest(WALLET_CONNECTOR_MESSENGER_ID, {\n      scope: 'accounts',\n      command: 'getAccounts'\n    }, timeout)\n\n    return result as Account[]\n  }\n\n  async signTransaction(args: SignSendTransactionArguments, timeout = 60000) {\n    const { result } = await this.messenger.sendRequest(WALLET_CONNECTOR_MESSENGER_ID, { \n      scope: 'signer', \n      command: 'signTransaction', \n      arguments: JSON.stringify(args) \n    }, timeout)\n\n    return result as SignSendTransactionResult\n  }\n\n  async signAndSendTransaction(args: SignSendTransactionArguments, timeout = 60000) {\n    const { result } = await this.messenger.sendRequest(WALLET_CONNECTOR_MESSENGER_ID, { \n      scope: 'signer', \n      command: 'signAndSendTransaction', \n      arguments: JSON.stringify(args) \n    }, timeout)\n\n    return result as SignSendTransactionResult\n  }\n}"],"names":["$37dc762e7429e685$var$PING_REQUEST_TYPE","$37dc762e7429e685$export$1182391b36b9d1bf","constructor","target","id","isTargetWindow","targetOrigin","this","onMessageListenerAdded","addMessageListener","onMessageListener","async","event","startsWith","origin","data","ports","type","to","postMessage","onRequestFn","sender","JSON","parse","sendData","sendError","error","close","onMessageFn","self","addEventListener","ping","targetId","numberOfAttempt","Error","_sendRequest","from","onMessage","onRequest","removeListener","removeEventListener","sendMessage","message","_sendMessage","stringify","sendRequest","timeout","Promise","resolve","reject","requestTimeout","port1","port2","MessageChannel","onmessage","evt","clearTimeout","setTimeout","$0b19e43e35dee0e8$var$loaded","$eb7869949b641a40$var$KOINOS_WALLET_IFRAME_CLASS","$eb7869949b641a40$var$WALLET_CONNECTOR_MESSENGER_ID","indexOf","document","readyState","window","then","getElementsByClassName","length","console","warn","catch","$eb7869949b641a40$export$2e2bcd8739ae039","walletUrl","iframe","createElement","hidden","onload","onIframeLoad","src","body","appendChild","checkIfAlreadyInitialized","messenger","contentWindow","log","static","result","scope","command","args","arguments"],"version":3,"file":"koinos-wallet.js.map"}